
## 1. **Реализованный алгоритм**

### **Описание**
- Алгоритм работает на основе **формул**, которые описывают шаги для поиска родственников.
- Каждая формула состоит из последовательности шагов, таких как:
  - `ELDRE(M)` — поиск родителей мужского пола.
  - `LIK(F)` — поиск супругов женского пола.
  - `UNG(M)` — поиск детей мужского пола.
- Формула может содержать несколько подформул, объединенных оператором `&&`.

### **Шаги работы**
1. Загрузка данных о людях, браках и родительских связях.
2. Разбор формулы на шаги.
3. Применение каждого шага к текущему набору людей.
4. Исключение уже обработанных людей для предотвращения циклов.
5. Сохранение результатов в файл `output.json`.

### **Преимущества**
- **Гибкость**: Формулы позволяют задавать произвольные запросы для поиска родственников.
- **Модульность**: Каждый шаг формулы обрабатывается независимо, что упрощает расширение функциональности.
- **Читаемость**: Формулы легко читаются и понимаются, что упрощает их использование и модификацию.

### **Недостатки**
- **Ограниченность**: Алгоритм работает только с предопределенными шагами (`ELDRE`, `LIK`, `UNG`). Для более сложных запросов требуется расширение функциональности.
- **Производительность**: При большом количестве людей и сложных формулах алгоритм может работать медленно из-за последовательного применения шагов.
- **Отсутствие оптимизации**: Алгоритм не использует оптимизации, такие как кэширование или предварительная обработка данных.

---

## 2. **Поиск в глубину (DFS)**

### **Описание**
- Поиск в глубину — это алгоритм обхода графа, который исследует все возможные пути до тех пор, пока не достигнет целевого узла или не пройдет все узлы.
- В контексте поиска родственных связей граф представляет собой связи между людьми (родители, супруги, дети).

### **Шаги работы**
1. Начать с исходного человека (корневой узел).
2. Рекурсивно исследовать всех соседей (родителей, супругов, детей).
3. Помечать посещенные узлы, чтобы избежать циклов.
4. Остановиться, когда все узлы будут исследованы или будет найден целевой человек.

### **Преимущества**
- **Универсальность**: DFS может быть использован для поиска любых связей в графе, включая сложные запросы.
- **Простота реализации**: Алгоритм легко реализовать и адаптировать под различные задачи.
- **Полнота**: DFS гарантированно найдет все возможные связи, если они существуют.

### **Недостатки**
- **Производительность**: В худшем случае (например, при большом количестве людей и связей) DFS может работать медленно.
- **Риск переполнения стека**: Рекурсивная реализация DFS может привести к переполнению стека при глубоких графах.
- **Отсутствие направленности**: DFS не учитывает направление поиска (например, только родителей или только детей), что может привести к избыточным вычислениям.

---

## 3. **Поиск в ширину (BFS, Breadth-First Search)**

### **Описание**
- Поиск в ширину — это алгоритм обхода графа, который исследует все узлы на текущем уровне перед переходом на следующий уровень.
- В контексте поиска родственных связей BFS может быть полезен для поиска кратчайших путей между людьми (например, минимальное количество шагов для нахождения связи).

### **Шаги работы**
1. Начать с исходного человека (корневой узел).
2. Добавить всех соседей (родителей, супругов, детей) в очередь.
3. Последовательно обрабатывать узлы из очереди, добавляя их соседей на следующий уровень.
4. Помечать посещенные узлы, чтобы избежать циклов.
5. Остановиться, когда все узлы будут исследованы или будет найден целевой человек.

### **Преимущества**
- **Кратчайший путь**: BFS гарантированно находит кратчайший путь между двумя узлами (например, минимальное количество шагов для нахождения родственника).
- **Универсальность**: Как и DFS, BFS может быть использован для поиска любых связей в графе.
- **Отсутствие риска переполнения стека**: BFS реализуется с использованием очереди, что исключает риск переполнения стека.

### **Недостатки**
- **Производительность**: BFS требует больше памяти, чем DFS, так как хранит все узлы текущего уровня в очереди.
- **Отсутствие направленности**: Как и DFS, BFS не учитывает направление поиска, что может привести к избыточным вычислениям.

---

## 6. **Сравнение реализованного алгоритма, DFS и BFS**

| Критерий                | Реализованный алгоритм          | Поиск в глубину (DFS)          | Поиск в ширину (BFS)           |
|-------------------------|---------------------------------|--------------------------------|--------------------------------|
| **Гибкость**            | Ограничен шагами формулы        | Универсален                   | Универсален                   |
| **Производительность**  | Медленный для сложных формул    | Медленный для больших графов  | Медленный для больших графов  |
| **Реализация**          | Модульная, легко расширяемая    | Простая, но менее гибкая      | Простая, но менее гибкая      |
| **Оптимизация**         | Отсутствует                    | Возможна (например, кэширование) | Возможна (например, кэширование) |
| **Читаемость**          | Высокая (формулы понятны)       | Низкая (код может быть сложным) | Низкая (код может быть сложным) |
| **Применимость**        | Для предопределенных запросов   | Для любых запросов            | Для любых запросов            |
| **Кратчайший путь**     | Не гарантирован                 | Не гарантирован               | Гарантирован                  |
| **Использование памяти**| Низкое                         | Низкое                        | Высокое                       |

---

## 7. **Сложность текущего алгоритма**

Для оценки сложности реализованного алгоритма необходимо проанализировать каждую часть кода и определить, как она зависит от входных данных. Основные параметры, которые влияют на сложность:
- **n** — количество людей в данных.
- **m** — количество шагов в формуле.
- **k** — среднее количество связей (родителей, супругов, детей) у одного человека.

---

## 7.1. **Загрузка данных (`load_people_data`)**
- Проход по массиву людей: **O(n)**.
- Проход по массиву браков: **O(m_marriages)**, где `m_marriages` — количество браков.
- Проход по массиву родительских связей: **O(m_parents)**, где `m_parents` — количество родительских связей.

Общая сложность: **O(n + m_marriages + m_parents)**.  
В худшем случае, если количество браков и родительских связей пропорционально количеству людей, сложность будет **O(n)**.

---

## 7.2. **Загрузка формул (`load_formulas`)**
- Чтение и парсинг JSON: **O(f)**, где `f` — размер файла с формулами.  
Обычно это константа, если формулы фиксированы.

---

## 7.3. **Разбор шага формулы (`parse_step`)**
- Используется регулярное выражение: **O(1)** для одного шага.  
Для всех шагов в формуле: **O(m)**, где `m` — количество шагов.

---

## 7.4. **Применение шага формулы (`apply_step`)**
- Фильтрация списка родителей, супругов или детей: **O(k)**, где `k` — среднее количество связей у человека.
- Исключение уже обработанных имен: **O(1)** для каждого имени (используется хэш-таблица).

Общая сложность для одного шага: **O(k)**.

---

## 7.5. **Обработка подформулы (`process_sub_formula`)**
- Для каждого шага в подформуле:
  - Применение шага: **O(k)**.
  - Обновление списка текущих людей: **O(k)**.
  - Исключение имен: **O(1)**.

Если подформула содержит `m` шагов, то сложность: **O(m * k)**.

---

## 7.6. **Вычисление родственников по формуле (`calculate_relatives`)**
- Разделение формулы на подформулы: **O(1)**.
- Для каждой подформулы:
  - Проверка валидности: **O(m)**.
  - Обработка подформулы: **O(m * k)**.

Если формула содержит `s` подформул, то общая сложность: **O(s * m * k)**.

---

## 7.7. **Основная функция (`main`)**
- Загрузка данных: **O(n)**.
- Загрузка формул: **O(1)**.
- Для каждой формулы:
  - Вычисление родственников: **O(s * m * k)**.
  - Добавление результатов: **O(r)**, где `r` — количество найденных родственников.

Если формул `f`, то общая сложность: **O(n + f * s * m * k)**.

---

## 7.8. **Итоговая сложность**
- В худшем случае:
  - Количество формул (`f`) и подформул (`s`) можно считать константами.
  - Количество шагов (`m`) и связей (`k`) зависит от структуры данных.
  - Основной вклад в сложность вносит обработка формул: **O(m * k)**.

Итоговая сложность: **O(n + m * k)**.


### Оценка сложности:
- **Время**:  
  `O(m * k * s)`, где:  
  - `m` — количество шагов в формуле,  
  - `k` — среднее количество связей (родителей, супругов, детей) у человека,  
  - `s` — количество подформул (разделенных `&&`).  

  Например, для формулы `ELDRE(M)/LIK(F) && UNG(M)`, сложность будет `O(2 * k * 2) = O(4k)`.

- **Память**:  
  `O(n)` — хранение данных о людях и промежуточных результатов.

---

## 8. **Сложность DFS (Depth-First Search)**
DFS рекурсивно обходит все связи, начиная от исходного человека, и исследует каждый путь до конца.

### Оценка сложности:
- **Время**:  
  `O(n + e)`, где:  
  - `n` — количество людей,  
  - `e` — количество связей (родитель-ребенок, супруги).  

  В худшем случае (полный граф) `e ≈ n^2`, что дает `O(n^2)`.

- **Память**:  
  `O(n)` — для хранения посещенных узлов и стека вызовов (рекурсия).

---

## 9. **Сложность BFS (Breadth-First Search)**
BFS исследует связи уровня за уровнем, используя очередь.

### Оценка сложности:
- **Время**:  
  Аналогично DFS: `O(n + e)`.  
  В худшем случае `O(n^2)`.

- **Память**:  
  `O(n)` — для хранения очереди и посещенных узлов.  
  В отличие от DFS, BFS может требовать больше памяти при широких графах.

---

## 10. **Сравнение сложностей**

| Параметр                | Текущий алгоритм       | DFS                | BFS                |
|-------------------------|------------------------|--------------------|--------------------|
| **Время (в среднем)**   | `O(m * k * s)`         | `O(n + e)`         | `O(n + e)`         |
| **Время (в худшем)**    | `O(m * k * s)`         | `O(n^2)`           | `O(n^2)`           |
| **Память**              | `O(n)`                 | `O(n)`             | `O(n)`             |
| **Оптимизация под запрос** | Да (шаги формулы)   | Нет                | Нет                |
| **Гарантирует кратчайший путь** | Нет             | Нет                | Да                 |

---

## 11. **Примеры**

### Пример 1: Поиск родителей мужского пола
- **Текущий алгоритм**:  
  Формула `ELDRE(M)`.  
  Сложность: `O(1 * k * 1) = O(k)`.

- **DFS/BFS**:  
  Обход всех родителей.  
  Сложность: `O(n + e)`.  
  В данном случае `e` — количество родительских связей.

**Итог**: Текущий алгоритм эффективнее, если `k` мало.

---

### Пример 2: Поиск всех потомков
- **Текущий алгоритм**:  
  Формула `UNG(M)/UNG(M)/...` (повторяется для каждого поколения).  
  Сложность: `O(m * k * s)`.  
  Для 3 поколений: `O(3 * k * 1) = O(3k)`.

- **DFS/BFS**:  
  Обход всех потомков.  
  Сложность: `O(n + e)`.  
  Если потомков много (например, `e ≈ n`), DFS/BFS будут работать за `O(n)`.

**Итог**: DFS/BFS эффективнее, если требуется найти всех потомков.

---

### Пример 3: Поиск супругов через несколько шагов
- **Текущий алгоритм**:  
  Формула `ELDRE(M)/LIK(F)`.  
  Сложность: `O(2 * k * 1) = O(2k)`.

- **DFS/BFS**:  
  Обход всех возможных связей.  
  Сложность: `O(n + e)`.  
  Если связей много, DFS/BFS будут медленнее.

**Итог**: Текущий алгоритм выигрывает, если путь известен.

---

## 12. **Выводы**
- **Текущий алгоритм**:
  - **Плюсы**:  
    - Эффективен для предопределенных шагов.  
    - Сложность зависит только от количества шагов и связей (`m * k`), а не от общего размера графа.  
  - **Минусы**:  
    - Не подходит для сложных запросов (например, "найти всех родственников до 5 колена").  

- **DFS/BFS**:
  - **Плюсы**:  
    - Универсальны для любых запросов.  
    - BFS гарантирует кратчайший путь.  
  - **Минусы**:  
    - Время работы зависит от общего количества связей (`e`), что может быть избыточно для простых запросов.  

---
